package qupath.ext.dlclassifier;

import javafx.application.Platform;
import javafx.beans.binding.Bindings;
import javafx.beans.binding.BooleanBinding;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.scene.control.CheckMenuItem;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuItem;
import javafx.scene.control.SeparatorMenuItem;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import qupath.ext.dlclassifier.controller.DLClassifierController;
import qupath.ext.dlclassifier.model.ClassifierMetadata;
import qupath.ext.dlclassifier.model.InferenceConfig;
import qupath.ext.dlclassifier.preferences.DLClassifierPreferences;
import qupath.ext.dlclassifier.service.ApposeService;
import qupath.ext.dlclassifier.service.BackendFactory;
import qupath.ext.dlclassifier.service.ClassifierBackend;
import qupath.ext.dlclassifier.service.DLPixelClassifier;
import qupath.ext.dlclassifier.service.ModelManager;
import qupath.ext.dlclassifier.service.OverlayService;
import qupath.ext.dlclassifier.model.ChannelConfiguration;
import qupath.ext.dlclassifier.ui.PythonConsoleWindow;
import qupath.ext.dlclassifier.ui.SetupEnvironmentDialog;
import qupath.ext.dlclassifier.ui.TooltipHelper;
import qupath.fx.dialogs.Dialogs;
import qupath.lib.common.GeneralTools;
import qupath.lib.common.Version;
import qupath.lib.gui.QuPathGUI;
import qupath.lib.gui.extensions.GitHubProject;
import qupath.lib.gui.extensions.QuPathExtension;
import qupath.lib.images.ImageData;

import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.List;
import java.util.ResourceBundle;

/**
 * Entry point for the Deep Learning Pixel Classifier extension.
 * <p>
 * This extension provides deep learning-based pixel classification capabilities for QuPath,
 * supporting both brightfield RGB and multi-channel fluorescence/spectral images.
 * <p>
 * Key features:
 * <ul>
 *   <li>Train custom pixel classifiers using sparse annotations</li>
 *   <li>Support for multi-channel images with per-channel normalization</li>
 *   <li>Pluggable model architecture system (UNet, SegFormer, etc.)</li>
 *   <li>REST API communication with Python deep learning server</li>
 *   <li>Output as measurements, objects, or classification overlays</li>
 * </ul>
 *
 * @author UW-LOCI
 * @since 0.1.0
 */
public class SetupDLClassifier implements QuPathExtension, GitHubProject {

    private static final Logger logger = LoggerFactory.getLogger(SetupDLClassifier.class);

    // Load extension metadata
    private static final ResourceBundle res = ResourceBundle.getBundle("qupath.ext.dlclassifier.ui.strings");
    private static final String EXTENSION_NAME = res.getString("name");
    private static final String EXTENSION_DESCRIPTION = res.getString("description");
    private static final Version EXTENSION_QUPATH_VERSION = Version.parse("v0.6.0");
    private static final GitHubRepo EXTENSION_REPOSITORY =
            GitHubRepo.create(EXTENSION_NAME, "uw-loci", "qupath-extension-DL-pixel-classifier");

    /**
     * Observable property tracking whether the DL environment is ready for use.
     * When true, workflow menu items are visible. When false, only the setup item is shown.
     */
    private final BooleanProperty environmentReady = new SimpleBooleanProperty(false);

    /** True if the backend (Appose or HTTP) has been initialized and is available. */
    private boolean serverAvailable;

    @Override
    public String getName() {
        return EXTENSION_NAME;
    }

    @Override
    public String getDescription() {
        return EXTENSION_DESCRIPTION;
    }

    @Override
    public Version getQuPathVersion() {
        return EXTENSION_QUPATH_VERSION;
    }

    @Override
    public GitHubRepo getRepository() {
        return EXTENSION_REPOSITORY;
    }

    @Override
    public void installExtension(QuPathGUI qupath) {
        logger.info("Installing extension: {}", EXTENSION_NAME);

        // Register persistent preferences
        DLClassifierPreferences.installPreferences(qupath);

        // Fast filesystem check to determine environment state (no downloads)
        updateEnvironmentState();

        // Listen for useAppose preference changes to reactively update menu visibility
        DLClassifierPreferences.useApposeProperty().addListener((obs, oldVal, newVal) ->
                Platform.runLater(this::updateEnvironmentState));

        // Build menu on the FX thread
        Platform.runLater(() -> addMenuItem(qupath));

        // If environment is already built, start background initialization of Python service
        if (environmentReady.get() && DLClassifierPreferences.isUseAppose()) {
            startBackgroundInitialization();
        }
    }

    /**
     * Determines the current environment state based on preferences and filesystem.
     * <p>
     * Three states:
     * <ul>
     *   <li>useAppose=false (HTTP mode) -> environmentReady=true immediately</li>
     *   <li>useAppose=true, env built -> environmentReady=true</li>
     *   <li>useAppose=true, env NOT built -> environmentReady=false</li>
     * </ul>
     */
    private void updateEnvironmentState() {
        if (!DLClassifierPreferences.isUseAppose()) {
            // HTTP mode - no environment needed
            environmentReady.set(true);
            logger.debug("HTTP backend mode - environment check skipped");
        } else if (ApposeService.isEnvironmentBuilt()) {
            environmentReady.set(true);
            logger.debug("Appose environment found on disk");
        } else {
            environmentReady.set(false);
            logger.info("Appose environment not found - setup required");
        }
    }

    /**
     * Starts background initialization of the Appose service when the environment
     * is already built. This pre-warms the Python subprocess so it is ready when
     * the user clicks a workflow item.
     * <p>
     * If initialization fails (e.g., packages not installed), sets
     * environmentReady to false so the setup item reappears.
     */
    private void startBackgroundInitialization() {
        Thread initThread = new Thread(() -> {
            try {
                ApposeService.getInstance().initialize();
                serverAvailable = true;
                logger.info("Appose backend initialized successfully (background)");
            } catch (Exception e) {
                logger.warn("Background Appose init failed: {}", e.getMessage());
                serverAvailable = false;
                // Environment exists on disk but isn't functional --
                // revert to "needs setup" state so the user can fix it
                Platform.runLater(() -> {
                    environmentReady.set(false);
                    Dialogs.showWarningNotification(
                            EXTENSION_NAME,
                            "Python environment exists but failed to initialize.\n" +
                                    "Use Setup DL Environment or Rebuild to fix.");
                });
            }
        }, "DLClassifier-BackgroundInit");
        initThread.setDaemon(true);
        initThread.start();
    }

    private void addMenuItem(QuPathGUI qupath) {
        // Create the top level Extensions > DL Pixel Classifier menu
        var extensionMenu = qupath.getMenu("Extensions>" + EXTENSION_NAME, true);

        // === SETUP MENU ITEM (visible only when environment not ready AND useAppose is on) ===
        MenuItem setupItem = new MenuItem(res.getString("menu.setupEnvironment"));
        TooltipHelper.installOnMenuItem(setupItem,
                "Download and configure the Python deep learning environment.\n" +
                        "Required for first-time use. Downloads approximately 2-4 GB.");
        setupItem.setOnAction(e -> showSetupDialog(qupath));

        // Binding: visible when environment is NOT ready AND Appose mode is on
        BooleanBinding showSetup = environmentReady.not()
                .and(DLClassifierPreferences.useApposeProperty());
        setupItem.visibleProperty().bind(showSetup);

        // Setup separator - visible only with setup item
        SeparatorMenuItem setupSeparator = new SeparatorMenuItem();
        setupSeparator.visibleProperty().bind(showSetup);

        // === MAIN WORKFLOW MENU ITEMS (visible when environmentReady) ===

        // 1) Train Classifier - create a new classifier from annotations
        MenuItem trainOption = new MenuItem(res.getString("menu.training"));
        TooltipHelper.installOnMenuItem(trainOption,
                "Train a new deep learning pixel classifier from annotated regions.\n" +
                        "Requires at least 2 annotation classes (e.g. Foreground/Background).\n" +
                        "Supports single-image and multi-image training from project images.");
        trainOption.disableProperty().bind(
                Bindings.createBooleanBinding(
                        () -> qupath.getProject() == null,
                        qupath.projectProperty()
                )
        );
        trainOption.setOnAction(e -> DLClassifierController.getInstance().startWorkflow("training"));
        trainOption.visibleProperty().bind(environmentReady);

        // 2) Apply Classifier - run inference on current image
        MenuItem inferenceOption = new MenuItem(res.getString("menu.inference"));
        TooltipHelper.installOnMenuItem(inferenceOption,
                "Apply a trained classifier to the current image or selected annotations.\n" +
                        "Results can be added as measurements, detection/annotation objects,\n" +
                        "or live classification overlays.");
        inferenceOption.disableProperty().bind(
                Bindings.createBooleanBinding(
                        () -> qupath.getImageData() == null,
                        qupath.imageDataProperty()
                )
        );
        inferenceOption.setOnAction(e -> DLClassifierController.getInstance().startWorkflow("inference"));
        inferenceOption.visibleProperty().bind(environmentReady);

        // Separator between train/inference and live prediction
        SeparatorMenuItem sep1 = new SeparatorMenuItem();
        sep1.visibleProperty().bind(environmentReady);

        // 3) Live DL Prediction - toggle live tile classification on/off
        //    When checked and no overlay exists, prompts user to select a classifier
        CheckMenuItem livePredictionOption = new CheckMenuItem(res.getString("menu.toggleOverlay"));
        TooltipHelper.installOnMenuItem(livePredictionOption,
                "Toggle live DL classification overlay on the current viewer.\n" +
                        "If no overlay exists, you will be prompted to select a classifier.\n" +
                        "When unchecked, the overlay is removed and GPU memory is freed.");
        OverlayService overlayService = OverlayService.getInstance();
        // Sync CheckMenuItem state from the property (for programmatic changes)
        overlayService.livePredictionProperty().addListener((obs, wasLive, isLive) ->
                livePredictionOption.setSelected(isLive));
        // Trigger overlay creation or removal when user clicks the CheckMenuItem
        livePredictionOption.setOnAction(e -> {
            if (livePredictionOption.isSelected()) {
                if (overlayService.hasOverlay()) {
                    // Overlay exists - just re-enable live prediction
                    overlayService.setLivePrediction(true);
                } else {
                    // No overlay - create one by prompting for classifier selection
                    createOverlayFromClassifierSelection(qupath, overlayService, livePredictionOption);
                }
            } else {
                // Unchecked - remove the overlay entirely
                overlayService.removeOverlay();
            }
        });
        livePredictionOption.disableProperty().bind(
                Bindings.createBooleanBinding(
                        () -> qupath.getImageData() == null,
                        qupath.imageDataProperty()
                )
        );
        livePredictionOption.visibleProperty().bind(environmentReady);

        // 4) Remove Overlay - fully remove and clean up resources
        MenuItem removeOverlayOption = new MenuItem(res.getString("menu.removeOverlay"));
        TooltipHelper.installOnMenuItem(removeOverlayOption,
                "Permanently remove the DL classification overlay and free GPU/CPU resources.\n" +
                        "Use this to reclaim memory after you are done viewing the overlay.");
        removeOverlayOption.setOnAction(e -> {
            overlayService.removeOverlay();
            Dialogs.showInfoNotification(EXTENSION_NAME, "Classification overlay removed.");
        });
        removeOverlayOption.visibleProperty().bind(environmentReady);

        // Separator before models
        SeparatorMenuItem sep2 = new SeparatorMenuItem();
        sep2.visibleProperty().bind(environmentReady);

        // 5) Manage Models - browse and manage saved classifiers
        MenuItem modelsOption = new MenuItem(res.getString("menu.manageModels"));
        TooltipHelper.installOnMenuItem(modelsOption,
                "Browse, import, export, and delete saved classifiers.\n" +
                        "View model metadata, training configuration, and class mappings.");
        modelsOption.setOnAction(e -> DLClassifierController.getInstance().startWorkflow("modelManagement"));
        modelsOption.visibleProperty().bind(environmentReady);

        // Separator before utilities
        SeparatorMenuItem sep3 = new SeparatorMenuItem();
        sep3.visibleProperty().bind(environmentReady);

        // === UTILITIES SUBMENU ===
        Menu utilitiesMenu = new Menu("Utilities");
        // Utilities submenu is always visible (contains Server Settings which is always available)

        // Server Settings - always visible
        MenuItem serverOption = new MenuItem(res.getString("menu.serverSettings"));
        TooltipHelper.installOnMenuItem(serverOption,
                "Configure the connection to the Python classification server.\n" +
                        "Test connectivity, view GPU availability, and check server version.");
        serverOption.setOnAction(e -> DLClassifierController.getInstance().startWorkflow("serverSettings"));

        // Free GPU Memory - visible when environment ready
        MenuItem freeGpuOption = new MenuItem("Free GPU Memory");
        TooltipHelper.installOnMenuItem(freeGpuOption,
                "Force-clear all GPU memory held by the classification server.\n" +
                        "Cancels running training jobs, clears cached models, and\n" +
                        "frees GPU VRAM. Use after a crash or failed training.");
        freeGpuOption.setOnAction(e -> {
            freeGpuOption.setDisable(true);
            Thread clearThread = new Thread(() -> {
                try {
                    ClassifierBackend backend = BackendFactory.getBackend();
                    String result = backend.clearGPUMemory();
                    Platform.runLater(() -> {
                        freeGpuOption.setDisable(false);
                        if (result != null) {
                            Dialogs.showInfoNotification(EXTENSION_NAME, result);
                        } else {
                            Dialogs.showErrorNotification(EXTENSION_NAME,
                                    "Failed to clear GPU memory. Is the backend available?");
                        }
                    });
                } catch (Exception ex) {
                    logger.error("GPU memory clear failed", ex);
                    Platform.runLater(() -> {
                        freeGpuOption.setDisable(false);
                        Dialogs.showErrorNotification(EXTENSION_NAME,
                                "Error clearing GPU memory: " + ex.getMessage());
                    });
                }
            }, "DLClassifier-FreeGPU");
            clearThread.setDaemon(true);
            clearThread.start();
        });
        freeGpuOption.visibleProperty().bind(environmentReady);

        // Rebuild DL Environment - always visible in Appose mode so users can
        // fix broken environments even when initialization has failed
        MenuItem rebuildItem = new MenuItem(res.getString("menu.rebuildEnvironment"));
        TooltipHelper.installOnMenuItem(rebuildItem,
                "Delete and re-download the Python deep learning environment.\n" +
                        "Use this if the environment becomes corrupted or you want a fresh install.");
        rebuildItem.setOnAction(e -> rebuildEnvironment(qupath));
        rebuildItem.visibleProperty().bind(DLClassifierPreferences.useApposeProperty());

        // System Info - visible when environment ready
        MenuItem systemInfoOption = new MenuItem("System Info...");
        TooltipHelper.installOnMenuItem(systemInfoOption,
                "Show detailed system information including GPU status,\n" +
                        "Python package versions, and platform details.\n" +
                        "All information is copyable for bug reports.");
        systemInfoOption.setOnAction(e -> showSystemInfo());
        systemInfoOption.visibleProperty().bind(environmentReady);

        // Python Console - visible when Appose mode is active and environment ready
        MenuItem pythonConsoleOption = new MenuItem(res.getString("menu.pythonConsole"));
        TooltipHelper.installOnMenuItem(pythonConsoleOption,
                "Show a live console window displaying Python process output.\n" +
                "Useful for monitoring model loading, inference, and debugging.");
        pythonConsoleOption.setOnAction(e -> PythonConsoleWindow.getInstance().show());
        pythonConsoleOption.visibleProperty().bind(
                environmentReady.and(DLClassifierPreferences.useApposeProperty()));

        utilitiesMenu.getItems().addAll(serverOption, freeGpuOption, systemInfoOption,
                pythonConsoleOption, new SeparatorMenuItem(), rebuildItem);

        // === BUILD FINAL MENU ===
        extensionMenu.getItems().addAll(
                setupItem,
                setupSeparator,
                trainOption,
                inferenceOption,
                sep1,
                livePredictionOption,
                removeOverlayOption,
                sep2,
                modelsOption,
                sep3,
                utilitiesMenu
        );

        logger.info("Menu items added for extension: {}", EXTENSION_NAME);
    }

    /**
     * Collects Java-side and Python-side system information and shows it
     * in a copyable text dialog.
     */
    private void showSystemInfo() {
        // Collect Java-side info immediately
        StringBuilder sb = new StringBuilder();
        sb.append("=== QuPath / Extension ===\n");
        sb.append("QuPath version: ").append(GeneralTools.getVersion()).append("\n");
        String extVersion = GeneralTools.getPackageVersion(SetupDLClassifier.class);
        sb.append("Extension: ").append(EXTENSION_NAME)
                .append(extVersion != null ? " v" + extVersion : "").append("\n");
        sb.append("Backend mode: ").append(
                DLClassifierPreferences.isUseAppose() ? "Appose (embedded Python)" : "HTTP (external server)")
                .append("\n");

        ApposeService appose = ApposeService.getInstance();
        if (appose.isAvailable()) {
            sb.append("Appose status: initialized\n");
            sb.append("GPU type: ").append(appose.getGpuType()).append("\n");
        } else {
            String err = appose.getInitError();
            sb.append("Appose status: NOT available");
            if (err != null) sb.append(" (").append(err).append(")");
            sb.append("\n");
        }
        sb.append("Environment path: ").append(ApposeService.getEnvironmentPath()).append("\n");
        sb.append("\n");

        sb.append("=== Java / OS ===\n");
        sb.append("OS: ").append(System.getProperty("os.name")).append(" ")
                .append(System.getProperty("os.version")).append(" (")
                .append(System.getProperty("os.arch")).append(")\n");
        sb.append("JVM: ").append(System.getProperty("java.vm.name")).append(" ")
                .append(System.getProperty("java.version")).append("\n");
        sb.append("Max heap: ").append(Runtime.getRuntime().maxMemory() / (1024 * 1024)).append(" MB\n");
        sb.append("Available processors: ").append(Runtime.getRuntime().availableProcessors()).append("\n");
        sb.append("\n");

        String javaInfo = sb.toString();

        // Now run the Python system_info script for package versions & GPU details
        if (appose.isAvailable()) {
            Dialogs.showInfoNotification(EXTENSION_NAME, "Collecting system information...");
            Thread infoThread = new Thread(() -> {
                String pythonInfo;
                try {
                    var task = appose.runTask("system_info", java.util.Map.of());
                    pythonInfo = String.valueOf(task.outputs.get("info_text"));
                } catch (Exception ex) {
                    logger.warn("Failed to collect Python system info: {}", ex.getMessage());
                    pythonInfo = "=== Python ===\nFailed to collect: " + ex.getMessage() + "\n";
                }

                String fullInfo = javaInfo + pythonInfo;
                Platform.runLater(() -> showSystemInfoDialog(fullInfo));
            }, "DLClassifier-SystemInfo");
            infoThread.setDaemon(true);
            infoThread.start();
        } else {
            String fullInfo = javaInfo + "=== Python ===\nAppose service not available.\n"
                    + "Python system info requires a working Appose environment.\n";
            showSystemInfoDialog(fullInfo);
        }
    }

    /**
     * Shows the system info in a dialog with a copyable text area.
     */
    private void showSystemInfoDialog(String infoText) {
        javafx.scene.control.TextArea textArea = new javafx.scene.control.TextArea(infoText);
        textArea.setEditable(false);
        textArea.setWrapText(false);
        textArea.setFont(javafx.scene.text.Font.font("monospace", 12));
        textArea.setPrefWidth(600);
        textArea.setPrefHeight(500);

        javafx.scene.control.Dialog<Void> dialog = new javafx.scene.control.Dialog<>();
        dialog.setTitle(EXTENSION_NAME + " - System Info");
        dialog.setHeaderText("System configuration and package versions");
        dialog.getDialogPane().setContent(textArea);
        dialog.getDialogPane().getButtonTypes().add(javafx.scene.control.ButtonType.CLOSE);
        dialog.setResizable(true);

        // Add a Copy button
        javafx.scene.control.ButtonType copyType = new javafx.scene.control.ButtonType(
                "Copy to Clipboard", javafx.scene.control.ButtonBar.ButtonData.LEFT);
        dialog.getDialogPane().getButtonTypes().add(copyType);

        // Prevent the Copy button from closing the dialog
        dialog.getDialogPane().lookupButton(copyType).addEventFilter(
                javafx.event.ActionEvent.ACTION, event -> {
                    javafx.scene.input.Clipboard clipboard = javafx.scene.input.Clipboard.getSystemClipboard();
                    javafx.scene.input.ClipboardContent content = new javafx.scene.input.ClipboardContent();
                    content.putString(infoText);
                    clipboard.setContent(content);
                    Dialogs.showInfoNotification(EXTENSION_NAME, "System info copied to clipboard.");
                    event.consume();
                });

        dialog.showAndWait();
    }

    /**
     * Shows the setup environment dialog for first-time installation.
     */
    private void showSetupDialog(QuPathGUI qupath) {
        SetupEnvironmentDialog dialog = new SetupEnvironmentDialog(
                qupath.getStage(),
                () -> {
                    environmentReady.set(true);
                    serverAvailable = true;
                    logger.info("Environment setup completed via dialog");
                }
        );
        dialog.show();
    }

    /**
     * Rebuilds the DL environment by shutting down, deleting, and re-setting up.
     */
    private void rebuildEnvironment(QuPathGUI qupath) {
        boolean confirm = Dialogs.showConfirmDialog(
                res.getString("menu.rebuildEnvironment"),
                "This will shut down the Python service, delete the current environment,\n" +
                        "and re-download all dependencies (~2-4 GB).\n\n" +
                        "Continue?");
        if (!confirm) {
            return;
        }

        // Shut down the running service and delete the environment
        try {
            ApposeService.getInstance().shutdown();
            ApposeService.getInstance().deleteEnvironment();
        } catch (Exception e) {
            logger.error("Failed to delete environment", e);
            Dialogs.showErrorNotification(EXTENSION_NAME,
                    "Failed to delete environment: " + e.getMessage());
            return;
        }

        // Update state and show setup dialog
        environmentReady.set(false);
        serverAvailable = false;
        showSetupDialog(qupath);
    }

    /**
     * Prompts the user to select a classifier and creates a live overlay.
     * Called when the user checks "Live DL Prediction" and no overlay exists.
     */
    private void createOverlayFromClassifierSelection(QuPathGUI qupath,
                                                       OverlayService overlayService,
                                                       CheckMenuItem livePredictionOption) {
        ImageData<BufferedImage> imageData = qupath.getImageData();
        if (imageData == null) {
            livePredictionOption.setSelected(false);
            Dialogs.showWarningNotification(EXTENSION_NAME, "No image is open.");
            return;
        }

        // List available classifiers
        ModelManager modelManager = new ModelManager();
        List<ClassifierMetadata> classifiers = modelManager.listClassifiers();
        if (classifiers.isEmpty()) {
            livePredictionOption.setSelected(false);
            Dialogs.showWarningNotification(EXTENSION_NAME,
                    "No classifiers available. Train a classifier first.");
            return;
        }

        // Show a choice dialog
        List<String> names = classifiers.stream()
                .map(c -> c.getName() + " (" + c.getId() + ")")
                .toList();
        String choice = Dialogs.showChoiceDialog("Select Classifier",
                "Choose a classifier for the live overlay:", names, names.get(0));
        if (choice == null) {
            livePredictionOption.setSelected(false);
            return;
        }

        // Find the selected classifier
        int selectedIdx = names.indexOf(choice);
        ClassifierMetadata metadata = classifiers.get(selectedIdx);

        // Build channel config from metadata
        List<String> expectedChannels = metadata.getExpectedChannelNames();
        List<Integer> selectedChannels = new java.util.ArrayList<>();
        for (int i = 0; i < Math.max(expectedChannels.size(), metadata.getInputChannels()); i++) {
            selectedChannels.add(i);
        }
        ChannelConfiguration channelConfig = ChannelConfiguration.builder()
                .selectedChannels(selectedChannels)
                .channelNames(expectedChannels)
                .bitDepth(metadata.getBitDepthTrained())
                .normalizationStrategy(metadata.getNormalizationStrategy())
                .build();

        // Build inference config for overlay mode
        // Overlap is computed from physical distance by DLPixelClassifier.buildPixelMetadata()
        // so we use a placeholder here; the actual padding is set via computePhysicalOverlap()
        InferenceConfig inferenceConfig = InferenceConfig.builder()
                .tileSize(metadata.getInputWidth())
                .overlap(64)
                .outputType(InferenceConfig.OutputType.OVERLAY)
                .build();

        // Create the pixel classifier and apply overlay
        DLPixelClassifier pixelClassifier = new DLPixelClassifier(
                metadata, channelConfig, inferenceConfig, imageData);
        overlayService.applyClassifierOverlay(imageData, pixelClassifier);
        Dialogs.showInfoNotification(EXTENSION_NAME,
                "Live DL overlay applied: " + metadata.getName());
    }

}
