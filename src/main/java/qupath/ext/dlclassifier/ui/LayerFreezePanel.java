package qupath.ext.dlclassifier.ui;

import javafx.application.Platform;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import qupath.ext.dlclassifier.service.ClassifierClient;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Panel for configuring which encoder layers to freeze during transfer learning.
 * <p>
 * This panel displays the layer structure of the selected model and allows
 * users to choose which layers to freeze (not train) vs. train. Earlier layers
 * typically capture general features and can be frozen, while later layers
 * are more task-specific and should be trained.
 *
 * @author UW-LOCI
 * @since 0.1.0
 */
public class LayerFreezePanel extends VBox {

    private static final Logger logger = LoggerFactory.getLogger(LayerFreezePanel.class);

    private final ObservableList<LayerItem> layers = FXCollections.observableArrayList();
    private final ListView<LayerItem> layerListView;
    private final ComboBox<String> presetCombo;
    private final Label statusLabel;

    private String currentArchitecture;
    private String currentEncoder;
    private ClassifierClient client;

    /**
     * Creates a new layer freeze panel.
     */
    public LayerFreezePanel() {
        setSpacing(10);
        setPadding(new Insets(10));

        // Header with info
        Label headerLabel = new Label("Transfer Learning Configuration");
        headerLabel.setStyle("-fx-font-weight: bold; -fx-font-size: 14px;");

        Label infoLabel = new Label(
                "Early layers learn universal features (edges, textures) that transfer well. " +
                "Later layers learn high-level concepts that need retraining for histopathology."
        );
        infoLabel.setWrapText(true);
        infoLabel.setStyle("-fx-text-fill: #666666;");

        // Preset selection - based on data available (affects overfitting risk)
        HBox presetBox = new HBox(10);
        presetBox.setAlignment(Pos.CENTER_LEFT);
        Label presetLabel = new Label("Training Data:");
        presetCombo = new ComboBox<>();
        presetCombo.getItems().addAll(
                "Small (<500 tiles) - Conservative",
                "Medium (500-5000) - Balanced",
                "Large (>5000) - Full adaptation",
                "Custom"
        );
        presetCombo.setValue("Medium (500-5000) - Balanced");
        presetCombo.setOnAction(e -> applyPreset());
        TooltipHelper.install(presetCombo,
                "Select a freeze strategy based on your dataset size:\n\n" +
                "Small (<500 tiles): Freeze most encoder layers to prevent overfitting.\n" +
                "  Best when you have limited annotations -- preserves pretrained features.\n\n" +
                "Medium (500-5000): Balanced freeze of early layers only.\n" +
                "  Good default for most histopathology projects.\n\n" +
                "Large (>5000): Fine-tune nearly all layers for best adaptation.\n" +
                "  Enough data to train most layers without overfitting.\n\n" +
                "Custom: Manually toggle individual layers below.");

        Button applyButton = new Button("Apply");
        TooltipHelper.install(applyButton, "Apply the selected freeze preset to all layers");
        applyButton.setOnAction(e -> applyPreset());
        presetBox.getChildren().addAll(presetLabel, presetCombo, applyButton);

        // Layer list
        layerListView = new ListView<>(layers);
        layerListView.setCellFactory(lv -> new LayerCell());
        layerListView.setPrefHeight(200);
        TooltipHelper.install(layerListView,
                "Model layers from early (top) to late (bottom).\n" +
                "Check a layer to freeze (skip training) it.\n" +
                "Green = early/general features, Red = late/specific features.\n\n" +
                "Early layers learn edges and textures -- these transfer well and\n" +
                "are safe to freeze. Later layers learn task-specific patterns\n" +
                "and benefit from fine-tuning on your data.");
        VBox.setVgrow(layerListView, Priority.ALWAYS);

        // Quick actions
        HBox actionBox = new HBox(10);
        actionBox.setAlignment(Pos.CENTER);

        Button freezeAllEncoderBtn = new Button("Freeze All Encoder");
        TooltipHelper.installWithLink(freezeAllEncoderBtn,
                "Freeze all encoder layers -- only the decoder will be trained.\n" +
                "Most conservative option, best for very small datasets (<200 tiles).\n" +
                "Fastest training since fewer parameters are updated.",
                "https://cs231n.github.io/transfer-learning/");
        freezeAllEncoderBtn.setOnAction(e -> setAllEncoderLayers(true));

        Button unfreezeAllBtn = new Button("Unfreeze All");
        TooltipHelper.install(unfreezeAllBtn,
                "Unfreeze all layers for full fine-tuning.\n" +
                "Most aggressive option -- best for large datasets (>5000 tiles).\n" +
                "Risk of overfitting with small datasets. Use a lower learning\n" +
                "rate (e.g. 1e-5) when fine-tuning all layers.");
        unfreezeAllBtn.setOnAction(e -> setAllLayers(false));

        Button recommendedBtn = new Button("Use Recommended");
        TooltipHelper.install(recommendedBtn,
                "Apply the server's recommended freeze configuration\n" +
                "based on the selected architecture and backbone.\n" +
                "The server analyzes layer depth and parameter counts\n" +
                "to suggest a balanced freeze strategy.");
        recommendedBtn.setOnAction(e -> applyRecommended());

        actionBox.getChildren().addAll(freezeAllEncoderBtn, unfreezeAllBtn, recommendedBtn);

        // Status
        statusLabel = new Label("Select architecture and encoder to view layers");
        statusLabel.setStyle("-fx-text-fill: #888888;");

        getChildren().addAll(headerLabel, infoLabel, presetBox, layerListView, actionBox, statusLabel);
    }

    /**
     * Sets the classifier client for fetching layer information.
     */
    public void setClient(ClassifierClient client) {
        this.client = client;
    }

    /**
     * Loads layers for the specified architecture and encoder.
     * <p>
     * Tries the Python server first for accurate parameter counts.
     * If the server is unavailable, uses a local fallback with known
     * layer structures for common encoders.
     * <p>
     * This method may be called from a background thread. All UI updates
     * are dispatched to the FX application thread via {@code Platform.runLater}.
     *
     * @param architecture model architecture (e.g., "unet")
     * @param encoder      encoder name (e.g., "resnet34")
     * @param numChannels  number of input channels
     * @param numClasses   number of output classes
     */
    public void loadLayers(String architecture, String encoder, int numChannels, int numClasses) {
        this.currentArchitecture = architecture;
        this.currentEncoder = encoder;

        Platform.runLater(() -> {
            layers.clear();
            statusLabel.setText("Loading layer structure...");
        });

        // Try server first for accurate parameter counts
        if (client != null) {
            try {
                List<ClassifierClient.LayerInfo> layerInfos = client.getModelLayers(
                        architecture, encoder, numChannels, numClasses);

                if (layerInfos != null && !layerInfos.isEmpty()) {
                    Platform.runLater(() -> {
                        for (ClassifierClient.LayerInfo info : layerInfos) {
                            LayerItem item = new LayerItem(
                                    info.name(),
                                    info.displayName(),
                                    info.paramCount(),
                                    info.isEncoder(),
                                    info.depth(),
                                    info.recommendedFreeze(),
                                    info.description()
                            );
                            item.setFrozen(info.recommendedFreeze());
                            layers.add(item);
                        }
                        updateStatus();
                    });
                    logger.info("Loaded {} layers from server for {}/{}",
                            layerInfos.size(), architecture, encoder);
                    return;
                }
            } catch (Exception e) {
                logger.debug("Server layer loading failed for {}/{}: {}",
                        architecture, encoder, e.getMessage());
            }
        }

        // Fallback: use local layer structure definitions
        List<LayerItem> localLayers = buildLocalLayerStructure(encoder);
        if (!localLayers.isEmpty()) {
            Platform.runLater(() -> {
                layers.addAll(localLayers);
                updateStatus();
            });
            logger.info("Loaded {} layers from local fallback for {}/{}",
                    localLayers.size(), architecture, encoder);
        } else {
            Platform.runLater(() ->
                    statusLabel.setText("Unknown encoder: " + encoder));
        }
    }

    /**
     * Builds layer structure from local knowledge of common encoder families.
     * Used as fallback when the Python server is not available.
     */
    private List<LayerItem> buildLocalLayerStructure(String encoder) {
        List<LayerItem> result = new ArrayList<>();
        boolean isHistology = encoder != null && encoder.contains("_") &&
                (encoder.contains("lunit") || encoder.contains("kather") || encoder.contains("tcga"));
        // Resolve the base encoder family
        String family = resolveEncoderFamily(encoder);

        if ("resnet".equals(family)) {
            // ResNet family (resnet18, resnet34, resnet50, resnet101, + histology variants)
            boolean isResnet50Plus = encoder != null &&
                    (encoder.contains("50") || encoder.contains("101"));
            result.add(makeLayer("encoder.conv1", "Encoder: Initial Conv", 0, true,
                    isResnet50Plus ? 9_408 : 9_408, true, isHistology));
            result.add(makeLayer("encoder.layer1", "Encoder: Block 1 (64 filters)", 1, true,
                    isResnet50Plus ? 215_808 : 73_984, true, isHistology));
            result.add(makeLayer("encoder.layer2", "Encoder: Block 2 (128 filters)", 2, true,
                    isResnet50Plus ? 1_219_584 : 295_424, true, isHistology));
            result.add(makeLayer("encoder.layer3", "Encoder: Block 3 (256 filters)", 3, true,
                    isResnet50Plus ? 7_098_368 : 1_180_672, false, isHistology));
            result.add(makeLayer("encoder.layer4", "Encoder: Block 4 (512 filters)", 4, true,
                    isResnet50Plus ? 14_964_736 : 4_720_640, false, isHistology));
        } else if ("efficientnet".equals(family)) {
            result.add(makeLayer("encoder._conv_stem", "Encoder: Stem Conv", 0, true,
                    864, true, false));
            result.add(makeLayer("encoder._blocks[0:4]", "Encoder: Blocks 0-3", 1, true,
                    15_000, true, false));
            result.add(makeLayer("encoder._blocks[4:10]", "Encoder: Blocks 4-9", 2, true,
                    60_000, true, false));
            result.add(makeLayer("encoder._blocks[10:18]", "Encoder: Blocks 10-17", 3, true,
                    300_000, false, false));
            result.add(makeLayer("encoder._blocks[18:]", "Encoder: Blocks 18+", 4, true,
                    500_000, false, false));
        } else if ("densenet".equals(family)) {
            result.add(makeLayer("encoder.features.conv0", "Encoder: Initial Conv", 0, true,
                    9_408, true, false));
            result.add(makeLayer("encoder.features.denseblock1", "Encoder: Dense Block 1", 1, true,
                    340_000, true, false));
            result.add(makeLayer("encoder.features.denseblock2", "Encoder: Dense Block 2", 2, true,
                    920_000, true, false));
            result.add(makeLayer("encoder.features.denseblock3", "Encoder: Dense Block 3", 3, true,
                    2_800_000, false, false));
            result.add(makeLayer("encoder.features.denseblock4", "Encoder: Dense Block 4", 4, true,
                    2_000_000, false, false));
        } else if ("vgg".equals(family)) {
            result.add(makeLayer("encoder.features[0:7]", "Encoder: Layers 1-2 (64 filters)", 0, true,
                    38_720, true, false));
            result.add(makeLayer("encoder.features[7:14]", "Encoder: Layers 3-4 (128 filters)", 1, true,
                    221_440, true, false));
            result.add(makeLayer("encoder.features[14:24]", "Encoder: Layers 5-7 (256 filters)", 2, true,
                    1_475_328, true, false));
            result.add(makeLayer("encoder.features[24:34]", "Encoder: Layers 8-10 (512 filters)", 3, true,
                    5_899_776, false, false));
            result.add(makeLayer("encoder.features[34:]", "Encoder: Layers 11-13 (512 filters)", 4, true,
                    5_899_776, false, false));
        } else if ("mobilenet".equals(family)) {
            result.add(makeLayer("encoder.features[0:2]", "Encoder: Initial Conv", 0, true,
                    1_200, true, false));
            result.add(makeLayer("encoder.features[2:5]", "Encoder: Blocks 1-3", 1, true,
                    15_000, true, false));
            result.add(makeLayer("encoder.features[5:9]", "Encoder: Blocks 4-7", 2, true,
                    100_000, true, false));
            result.add(makeLayer("encoder.features[9:14]", "Encoder: Blocks 8-12", 3, true,
                    500_000, false, false));
            result.add(makeLayer("encoder.features[14:]", "Encoder: Blocks 13+", 4, true,
                    1_200_000, false, false));
        } else if ("se_resnet".equals(family)) {
            result.add(makeLayer("encoder.layer0", "Encoder: Initial Conv", 0, true,
                    9_408, true, false));
            result.add(makeLayer("encoder.layer1", "Encoder: SE Block 1 (64 filters)", 1, true,
                    300_000, true, false));
            result.add(makeLayer("encoder.layer2", "Encoder: SE Block 2 (128 filters)", 2, true,
                    1_500_000, true, false));
            result.add(makeLayer("encoder.layer3", "Encoder: SE Block 3 (256 filters)", 3, true,
                    8_500_000, false, false));
            result.add(makeLayer("encoder.layer4", "Encoder: SE Block 4 (512 filters)", 4, true,
                    17_000_000, false, false));
        } else {
            // Generic fallback for unknown encoders
            result.add(makeLayer("encoder.layer_early", "Encoder: Early Layers", 0, true,
                    0, true, false));
            result.add(makeLayer("encoder.layer_mid", "Encoder: Middle Layers", 2, true,
                    0, false, false));
            result.add(makeLayer("encoder.layer_late", "Encoder: Late Layers", 4, true,
                    0, false, false));
        }

        // Add decoder and segmentation head (always present)
        result.add(new LayerItem("decoder", "Decoder (all layers)", 0,
                false, 5, false,
                "Task-specific layers - should always be trained"));
        result.add(new LayerItem("segmentation_head", "Segmentation Head", 0,
                false, 6, false,
                "Final classification layer - must be trained"));

        return result;
    }

    private String resolveEncoderFamily(String encoder) {
        if (encoder == null) return "unknown";
        // Histology variants are resnet50-based
        if (encoder.contains("lunit") || encoder.contains("kather") || encoder.contains("tcga")) {
            return "resnet";
        }
        if (encoder.startsWith("resnet")) return "resnet";
        if (encoder.startsWith("efficientnet")) return "efficientnet";
        if (encoder.startsWith("densenet")) return "densenet";
        if (encoder.startsWith("vgg")) return "vgg";
        if (encoder.startsWith("mobilenet")) return "mobilenet";
        if (encoder.startsWith("se_resnet")) return "se_resnet";
        return "unknown";
    }

    private LayerItem makeLayer(String name, String displayName, int depth,
                                 boolean isEncoder, int paramCount,
                                 boolean recommendedFreeze, boolean isHistology) {
        String description = getLayerDescription(depth, isHistology);
        LayerItem item = new LayerItem(name, displayName, paramCount,
                isEncoder, depth, recommendedFreeze, description);
        item.setFrozen(recommendedFreeze);
        return item;
    }

    private String getLayerDescription(int depth, boolean isHistology) {
        if (isHistology) {
            return switch (depth) {
                case 0 -> "Basic tissue textures - already tissue-aware, safe to freeze";
                case 1 -> "Cell-level patterns - tissue-relevant, freeze for small datasets";
                case 2 -> "Tissue microstructure - already captures histology patterns";
                case 3 -> "Tissue architecture features - train for best adaptation";
                case 4 -> "High-level tissue semantics - fine-tune for your task";
                default -> "Deep features - likely need retraining";
            };
        }
        return switch (depth) {
            case 0 -> "Edges, gradients, basic textures - universal features, freeze";
            case 1 -> "Low-level patterns - transfer well across domains, freeze";
            case 2 -> "Texture combinations - partial transfer, consider fine-tuning";
            case 3 -> "Mid-level shapes - limited transfer to histopathology, train";
            case 4 -> "High-level semantic features - must retrain for histopathology";
            default -> "Deep features - likely need retraining";
        };
    }

    /**
     * Gets the list of layer names that should be frozen.
     */
    public List<String> getFrozenLayerNames() {
        return layers.stream()
                .filter(LayerItem::isFrozen)
                .map(LayerItem::getName)
                .collect(Collectors.toList());
    }

    /**
     * Gets all layers and their freeze state.
     */
    public List<LayerItem> getLayers() {
        return new ArrayList<>(layers);
    }

    private void applyPreset() {
        if (layers.isEmpty()) return;

        String selection = presetCombo.getValue();
        String datasetSize;

        if (selection.contains("Small")) {
            datasetSize = "small";
        } else if (selection.contains("Medium")) {
            datasetSize = "medium";
        } else if (selection.contains("Large")) {
            datasetSize = "large";
        } else {
            return; // Custom - don't change
        }

        Map<Integer, Boolean> recommendations = null;

        // Try server first
        if (client != null) {
            try {
                recommendations = client.getFreezeRecommendations(
                        datasetSize, currentEncoder);
            } catch (Exception e) {
                logger.debug("Server freeze recommendations unavailable: {}", e.getMessage());
            }
        }

        // Local fallback
        if (recommendations == null) {
            recommendations = getLocalFreezeRecommendations(datasetSize, currentEncoder);
        }

        for (LayerItem layer : layers) {
            Boolean freeze = recommendations.get(layer.getDepth());
            if (freeze != null) {
                layer.setFrozen(freeze);
            }
        }

        layerListView.refresh();
        updateStatus();
        logger.info("Applied {} preset for encoder {}: {} layers frozen",
                datasetSize, currentEncoder, getFrozenLayerNames().size());
    }

    /**
     * Local fallback for freeze recommendations when the server is unavailable.
     * Mirrors the logic in pretrained_models.py.
     */
    private Map<Integer, Boolean> getLocalFreezeRecommendations(String datasetSize,
                                                                  String encoder) {
        boolean isHistology = encoder != null &&
                (encoder.contains("lunit") || encoder.contains("kather") || encoder.contains("tcga"));

        Map<Integer, Boolean> recs = new java.util.HashMap<>();
        if (isHistology) {
            switch (datasetSize) {
                case "small" -> { recs.put(0, true); recs.put(1, true);
                    recs.put(2, false); recs.put(3, false); recs.put(4, false); }
                case "medium" -> { recs.put(0, true); recs.put(1, false);
                    recs.put(2, false); recs.put(3, false); recs.put(4, false); }
                default -> { recs.put(0, false); recs.put(1, false);
                    recs.put(2, false); recs.put(3, false); recs.put(4, false); }
            }
        } else {
            switch (datasetSize) {
                case "small" -> { recs.put(0, true); recs.put(1, true);
                    recs.put(2, true); recs.put(3, true); recs.put(4, false); }
                case "medium" -> { recs.put(0, true); recs.put(1, true);
                    recs.put(2, true); recs.put(3, false); recs.put(4, false); }
                default -> { recs.put(0, true); recs.put(1, true);
                    recs.put(2, false); recs.put(3, false); recs.put(4, false); }
            }
        }
        return recs;
    }

    private void applyRecommended() {
        for (LayerItem layer : layers) {
            layer.setFrozen(layer.isRecommendedFreeze());
        }
        layerListView.refresh();
        updateStatus();
    }

    private void setAllEncoderLayers(boolean frozen) {
        for (LayerItem layer : layers) {
            if (layer.isEncoder()) {
                layer.setFrozen(frozen);
            }
        }
        layerListView.refresh();
        updateStatus();
    }

    private void setAllLayers(boolean frozen) {
        for (LayerItem layer : layers) {
            layer.setFrozen(frozen);
        }
        layerListView.refresh();
        updateStatus();
    }

    private void updateStatus() {
        int frozenCount = 0;
        int totalParams = 0;
        int frozenParams = 0;

        for (LayerItem layer : layers) {
            totalParams += layer.getParamCount();
            if (layer.isFrozen()) {
                frozenCount++;
                frozenParams += layer.getParamCount();
            }
        }

        int trainableParams = totalParams - frozenParams;
        double trainablePercent = totalParams > 0 ? 100.0 * trainableParams / totalParams : 0;

        statusLabel.setText(String.format(
                "%d/%d layers frozen | %,d trainable params (%.1f%%)",
                frozenCount, layers.size(), trainableParams, trainablePercent
        ));
    }

    /**
     * Custom cell for displaying layers with freeze checkbox.
     */
    private class LayerCell extends ListCell<LayerItem> {
        private final HBox container;
        private final CheckBox freezeCheck;
        private final Label nameLabel;
        private final Label paramsLabel;
        private final Label descLabel;
        private final Rectangle depthIndicator;

        public LayerCell() {
            container = new HBox(10);
            container.setAlignment(Pos.CENTER_LEFT);
            container.setPadding(new Insets(5));

            freezeCheck = new CheckBox();
            freezeCheck.setOnAction(e -> {
                LayerItem item = getItem();
                if (item != null) {
                    item.setFrozen(freezeCheck.isSelected());
                    updateStatus();
                }
            });

            depthIndicator = new Rectangle(8, 30);

            VBox textBox = new VBox(2);
            nameLabel = new Label();
            nameLabel.setStyle("-fx-font-weight: bold;");

            HBox detailBox = new HBox(10);
            paramsLabel = new Label();
            paramsLabel.setStyle("-fx-text-fill: #666666; -fx-font-size: 11px;");
            descLabel = new Label();
            descLabel.setStyle("-fx-text-fill: #888888; -fx-font-size: 11px;");
            descLabel.setMaxWidth(300);
            detailBox.getChildren().addAll(paramsLabel, descLabel);

            textBox.getChildren().addAll(nameLabel, detailBox);
            HBox.setHgrow(textBox, Priority.ALWAYS);

            container.getChildren().addAll(freezeCheck, depthIndicator, textBox);
        }

        @Override
        protected void updateItem(LayerItem item, boolean empty) {
            super.updateItem(item, empty);

            if (empty || item == null) {
                setGraphic(null);
            } else {
                freezeCheck.setSelected(item.isFrozen());
                nameLabel.setText(item.getDisplayName());
                paramsLabel.setText(formatParams(item.getParamCount()));
                descLabel.setText(item.getDescription());

                // Color based on depth (green=early/freeze, red=late/train)
                double hue = 120 - (item.getDepth() * 20); // Green to red
                hue = Math.max(0, Math.min(120, hue));
                depthIndicator.setFill(Color.hsb(hue, 0.6, 0.8));

                // Visual feedback for frozen state
                if (item.isFrozen()) {
                    container.setStyle("-fx-background-color: #f0f8ff;");
                } else {
                    container.setStyle("-fx-background-color: #fff8f0;");
                }

                setGraphic(container);
            }
        }

        private String formatParams(int params) {
            if (params >= 1_000_000) {
                return String.format("%.1fM params", params / 1_000_000.0);
            } else if (params >= 1_000) {
                return String.format("%.1fK params", params / 1_000.0);
            } else {
                return params + " params";
            }
        }
    }

    /**
     * Data class for a layer item.
     */
    public static class LayerItem {
        private final String name;
        private final String displayName;
        private final int paramCount;
        private final boolean isEncoder;
        private final int depth;
        private final boolean recommendedFreeze;
        private final String description;
        private final BooleanProperty frozen = new SimpleBooleanProperty(false);

        public LayerItem(String name, String displayName, int paramCount,
                         boolean isEncoder, int depth, boolean recommendedFreeze,
                         String description) {
            this.name = name;
            this.displayName = displayName;
            this.paramCount = paramCount;
            this.isEncoder = isEncoder;
            this.depth = depth;
            this.recommendedFreeze = recommendedFreeze;
            this.description = description;
        }

        public String getName() { return name; }
        public String getDisplayName() { return displayName; }
        public int getParamCount() { return paramCount; }
        public boolean isEncoder() { return isEncoder; }
        public int getDepth() { return depth; }
        public boolean isRecommendedFreeze() { return recommendedFreeze; }
        public String getDescription() { return description; }

        public boolean isFrozen() { return frozen.get(); }
        public void setFrozen(boolean value) { frozen.set(value); }
        public BooleanProperty frozenProperty() { return frozen; }
    }
}
