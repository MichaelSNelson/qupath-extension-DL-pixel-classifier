package qupath.ext.dlclassifier.service;

import org.apposed.appose.Appose;
import org.apposed.appose.Environment;
import org.apposed.appose.Service;
import org.apposed.appose.Service.Task;
import org.apposed.appose.Service.ResponseType;
import org.apposed.appose.TaskException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Map;
import java.util.function.Consumer;
import java.util.stream.Collectors;

/**
 * Singleton managing the Appose Environment and Python Service lifecycle.
 * <p>
 * Provides an embedded Python runtime for DL inference and training via
 * Appose's shared-memory IPC. The Python worker is a single long-lived
 * subprocess -- globals set in {@code init()} persist across task calls,
 * enabling model caching without per-request overhead.
 * <p>
 * The Appose environment is built from a {@code pixi.toml} bundled in the
 * JAR resources. First-time setup downloads Python, PyTorch, and
 * dependencies (~2-4 GB). Subsequent launches reuse the cached environment.
 *
 * @author UW-LOCI
 * @since 0.2.0
 */
public class ApposeService {

    private static final Logger logger = LoggerFactory.getLogger(ApposeService.class);

    private static final String RESOURCE_BASE = "qupath/ext/dlclassifier/";
    private static final String PIXI_TOML_RESOURCE = RESOURCE_BASE + "pixi.toml";
    private static final String SCRIPTS_BASE = RESOURCE_BASE + "scripts/";
    private static final String ENV_NAME = "dl-pixel-classifier";

    private static ApposeService instance;

    private Environment environment;
    private Service pythonService;
    private boolean initialized;
    private boolean cudaAvailable;
    private String initError;
    private Thread shutdownHook;

    private ApposeService() {
        // Private constructor for singleton
    }

    /**
     * Gets the singleton instance.
     *
     * @return the ApposeService instance
     */
    public static synchronized ApposeService getInstance() {
        if (instance == null) {
            instance = new ApposeService();
        }
        return instance;
    }

    /**
     * Checks if the Appose pixi environment appears to be built on disk.
     * This is a fast filesystem check -- it does NOT trigger any downloads.
     *
     * @return true if the environment directory exists and appears installed
     */
    public static boolean isEnvironmentBuilt() {
        // If environment has been built this session, use its actual base path
        ApposeService svc = instance;
        if (svc != null && svc.environment != null) {
            Path envDir = Path.of(svc.environment.base());
            return Files.isDirectory(envDir.resolve(".pixi"));
        }
        // Fallback: check the default Appose data directory
        Path envDir = getEnvironmentPath();
        return Files.isDirectory(envDir.resolve(".pixi"));
    }

    /**
     * Returns the path where the Appose pixi environment is stored.
     * Uses the live environment base path if available, otherwise falls
     * back to Appose's default data directory.
     *
     * @return the environment directory path
     */
    public static Path getEnvironmentPath() {
        // If environment has been built this session, use its actual base path
        ApposeService svc = instance;
        if (svc != null && svc.environment != null) {
            return Path.of(svc.environment.base());
        }
        // Appose default: ~/.local/share/appose/<env-name>
        return Path.of(System.getProperty("user.home"),
                ".local", "share", "appose", ENV_NAME);
    }

    /**
     * Builds the pixi environment and starts the Python service.
     * <p>
     * This is slow the first time (downloads ~2-4 GB of dependencies)
     * but instant on subsequent runs. Should be called from a background
     * thread with progress reporting.
     *
     * @throws IOException if resource loading or environment build fails
     */
    public synchronized void initialize() throws IOException {
        initialize(null, true);
    }

    /**
     * Builds the pixi environment and starts the Python service with
     * status reporting and optional ONNX support.
     * <p>
     * The statusCallback receives human-readable progress messages suitable
     * for display in a setup dialog. Pass null for no status reporting.
     *
     * @param statusCallback optional callback for progress messages (may be null)
     * @param includeOnnx    if false, strips ONNX dependencies from the environment
     * @throws IOException if resource loading or environment build fails
     */
    public synchronized void initialize(Consumer<String> statusCallback,
                                         boolean includeOnnx) throws IOException {
        if (initialized) {
            report(statusCallback, "Already initialized");
            return;
        }

        try {
            report(statusCallback, "Loading environment configuration...");
            logger.info("Initializing Appose environment...");

            // Load pixi.toml from JAR resources
            String pixiToml = loadResource(PIXI_TOML_RESOURCE);

            // Optionally strip ONNX dependencies to reduce download size
            if (!includeOnnx) {
                pixiToml = stripOnnxDependencies(pixiToml);
                logger.info("ONNX dependencies excluded from environment");
            }

            // ALL Appose operations require the extension classloader as TCCL.
            // Appose and its dependencies (Groovy JSON) use ServiceLoader internally:
            //   - Scheme/BuilderFactory: during environment build
            //   - FastStringService (Groovy): during task JSON serialization
            //   - ShmFactory: during NDArray/SharedMemory allocation
            // QuPath extension threads don't propagate the extension classloader
            // to TCCL, so ServiceLoader.load() fails to find implementations.
            ClassLoader original = Thread.currentThread().getContextClassLoader();
            Thread.currentThread().setContextClassLoader(ApposeService.class.getClassLoader());

            try {
                // Ensure the pixi.toml on disk matches the bundled content.
                // Appose skips the build when the environment directory already
                // exists, so a changed pixi.toml in the JAR would never be
                // written to disk. Force-sync it here and delete the lockfile
                // so pixi re-resolves with the new dependencies.
                syncPixiToml(pixiToml);

                report(statusCallback, "Building pixi environment (this may take several minutes)...");

                // Build the pixi environment (downloads deps on first run)
                environment = Appose.pixi()
                        .content(pixiToml)
                        .scheme("pixi.toml")
                        .name(ENV_NAME)
                        .logDebug()
                        .build();

                logger.info("Appose environment built successfully");
                report(statusCallback, "Starting Python service...");

                // Create Python service (lazy - subprocess starts on first task)
                pythonService = environment.python();

                // Register debug output handler -- log Python stderr at INFO level
                // so diagnostic messages (device info, training config) are visible
                pythonService.debug(msg -> logger.info("[Appose Python] {}", msg));

                // Set the init script that runs when the Python subprocess starts.
                // IMPORTANT: init() can only be called ONCE -- each call replaces
                // the previous script. We prepend "import numpy" before the main
                // init script because NumPy must be imported BEFORE the Appose
                // stdin reader thread starts, or it deadlocks on Windows.
                // See: https://github.com/numpy/numpy/issues/24290
                String initScript = "import numpy\n" + loadScript("init_services.py");
                pythonService.init(initScript);

                // Force the Python subprocess to actually start and verify
                // that all critical packages are installed and importable.
                // pythonService.init() is lazy and queues scripts without
                // executing them, so we must run a blocking task() to confirm
                // the environment is truly functional.
                report(statusCallback, "Verifying installed packages (this may take a moment)...");
                logger.info("Running environment verification task...");

                String verifyScript =
                        "import torch\n" +
                        "import segmentation_models_pytorch\n" +
                        "import albumentations\n" +
                        "import numpy\n" +
                        "import PIL\n" +
                        "task.outputs['torch_version'] = torch.__version__\n" +
                        "task.outputs['cuda_available'] = str(torch.cuda.is_available())\n";

                Task verifyTask = pythonService.task(verifyScript);
                verifyTask.listen(event -> {
                    if (event.responseType == ResponseType.FAILURE
                            || event.responseType == ResponseType.CRASH) {
                        logger.error("Verification task failed: {}", verifyTask.error);
                    }
                });
                verifyTask.waitFor();

                String torchVersion = String.valueOf(verifyTask.outputs.get("torch_version"));
                String cudaStr = String.valueOf(verifyTask.outputs.get("cuda_available"));
                logger.info("Environment verified: PyTorch {}, CUDA={}", torchVersion, cudaStr);

                if (!"True".equalsIgnoreCase(cudaStr)) {
                    logger.warn("CUDA is NOT available -- training and inference will run on CPU (very slow). "
                            + "Rebuild the environment to install GPU-enabled PyTorch.");
                }

                initialized = true;
                initError = null;
                this.cudaAvailable = "True".equalsIgnoreCase(cudaStr);
                registerShutdownHook();
                String deviceNote = this.cudaAvailable ? "GPU" : "CPU only";
                report(statusCallback, "Setup complete! (PyTorch " + torchVersion
                        + ", " + deviceNote + ")");
                logger.info("Appose Python service initialized");
            } finally {
                Thread.currentThread().setContextClassLoader(original);
            }

        } catch (Exception e) {
            initError = e.getMessage();
            initialized = false;
            logger.error("Failed to initialize Appose: {}", e.getMessage(), e);
            throw e instanceof IOException ? (IOException) e : new IOException(e);
        }
    }

    /**
     * Runs a named task script with the given inputs.
     * <p>
     * The script is loaded from JAR resources under
     * {@code scripts/<scriptName>.py}. The Python worker must already
     * be initialized via {@link #initialize()}.
     *
     * @param scriptName script name without .py extension (e.g. "inference_pixel")
     * @param inputs     map of input values passed to the script
     * @return the completed Task with outputs
     * @throws IOException if the service is not available or the task fails
     */
    public Task runTask(String scriptName, Map<String, Object> inputs) throws IOException {
        ensureInitialized();

        String script;
        try {
            script = loadScript(scriptName + ".py");
        } catch (IOException e) {
            throw new IOException("Failed to load task script: " + scriptName, e);
        }

        // TCCL must be set for Groovy JSON serialization (Messages.encode)
        // and SharedMemory/NDArray operations (ShmFactory ServiceLoader).
        ClassLoader original = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader(ApposeService.class.getClassLoader());
        try {
            Task task = pythonService.task(script, inputs);
            task.listen(event -> {
                if (event.responseType == ResponseType.FAILURE
                        || event.responseType == ResponseType.CRASH) {
                    logger.error("Appose task '{}' {}: {}", scriptName,
                            event.responseType, task.error);
                }
            });
            task.waitFor();
            return task;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new IOException("Appose task '" + scriptName + "' interrupted", e);
        } catch (TaskException e) {
            throw new IOException("Appose task '" + scriptName + "' failed: " + e.getMessage(), e);
        } finally {
            Thread.currentThread().setContextClassLoader(original);
        }
    }

    /**
     * Runs a task script with inputs and a custom event listener.
     * <p>
     * Use this for long-running tasks (training) where progress events
     * need to be forwarded to the UI.
     *
     * @param scriptName    script name without .py extension
     * @param inputs        input values
     * @param eventListener listener for task events (progress, completion, etc.)
     * @return the completed Task with outputs
     * @throws IOException if the service is not available or the task fails
     */
    public Task runTaskWithListener(String scriptName, Map<String, Object> inputs,
                                    java.util.function.Consumer<org.apposed.appose.TaskEvent> eventListener)
            throws IOException {
        ensureInitialized();

        String script;
        try {
            script = loadScript(scriptName + ".py");
        } catch (IOException e) {
            throw new IOException("Failed to load task script: " + scriptName, e);
        }

        ClassLoader original = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader(ApposeService.class.getClassLoader());
        try {
            Task task = pythonService.task(script, inputs);
            task.listen(eventListener::accept);
            task.waitFor();
            return task;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new IOException("Appose task '" + scriptName + "' interrupted", e);
        } catch (TaskException e) {
            throw new IOException("Appose task '" + scriptName + "' failed: " + e.getMessage(), e);
        } finally {
            Thread.currentThread().setContextClassLoader(original);
        }
    }

    /**
     * Creates a task without waiting for it. Caller is responsible for
     * calling {@code task.waitFor()} and handling exceptions.
     * <p>
     * Use this for tasks that need cancellation support (e.g. training).
     *
     * @param scriptName script name without .py extension
     * @param inputs     input values
     * @return the Task (not yet started -- call {@code start()} or {@code waitFor()})
     * @throws IOException if the service is not available
     */
    public Task createTask(String scriptName, Map<String, Object> inputs) throws IOException {
        ensureInitialized();

        String script;
        try {
            script = loadScript(scriptName + ".py");
        } catch (IOException e) {
            throw new IOException("Failed to load task script: " + scriptName, e);
        }

        // TCCL needed for Groovy JSON serialization when task.start() is called.
        // Note: the caller must also ensure TCCL is set when calling task.waitFor()
        // if the task uses NDArray (SharedMemory deserialization).
        ClassLoader original = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader(ApposeService.class.getClassLoader());
        try {
            return pythonService.task(script, inputs);
        } finally {
            Thread.currentThread().setContextClassLoader(original);
        }
    }

    /**
     * Gracefully shuts down the Python service and environment.
     * Closes stdin first (lets Python exit cleanly), then force-kills
     * if the process doesn't exit within 5 seconds.
     */
    public synchronized void shutdown() {
        if (pythonService != null) {
            try {
                logger.info("Shutting down Appose Python service...");
                pythonService.close();  // closes stdin -> Python gets EOFError

                // Poll up to 5 seconds for graceful exit, then force kill
                if (pythonService.isAlive()) {
                    long deadline = System.currentTimeMillis() + 5000;
                    while (pythonService.isAlive() && System.currentTimeMillis() < deadline) {
                        try {
                            Thread.sleep(200);
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                            break;
                        }
                    }
                }
                if (pythonService.isAlive()) {
                    logger.warn("Python service did not exit gracefully, force-killing");
                    pythonService.kill();
                }
            } catch (Exception e) {
                // Last resort: force kill
                try {
                    pythonService.kill();
                } catch (Exception ignored) {
                    // nothing more we can do
                }
                logger.warn("Error during Python service shutdown: {}", e.getMessage());
            }
            pythonService = null;
        }
        initialized = false;

        // Remove shutdown hook if we're not being called from it
        removeShutdownHook();

        logger.info("Appose service shut down");
    }

    /**
     * Deletes the Appose pixi environment from disk.
     * The service must be shut down first via {@link #shutdown()}.
     * Uses the Appose Environment API if available, otherwise falls
     * back to recursive directory deletion.
     *
     * @throws IOException if the environment directory cannot be deleted
     */
    public synchronized void deleteEnvironment() throws IOException {
        if (pythonService != null) {
            throw new IOException("Cannot delete environment while Python service is running. "
                    + "Call shutdown() first.");
        }
        if (environment != null) {
            try {
                logger.info("Deleting Appose environment via API: {}", environment.base());
                environment.delete();
                environment = null;
                logger.info("Appose environment deleted");
                return;
            } catch (Exception e) {
                logger.warn("Appose environment.delete() failed, falling back to manual deletion: {}",
                        e.getMessage());
                environment = null;
            }
        }
        // Fallback: manual deletion of the default path
        Path envPath = getEnvironmentPath();
        if (Files.exists(envPath)) {
            logger.info("Deleting environment directory: {}", envPath);
            deleteDirectoryRecursively(envPath);
            logger.info("Environment directory deleted");
        }
    }

    /**
     * Recursively deletes a directory and all its contents.
     */
    private static void deleteDirectoryRecursively(Path directory) throws IOException {
        java.nio.file.FileVisitor<Path> visitor = new java.nio.file.SimpleFileVisitor<>() {
            @Override
            public java.nio.file.FileVisitResult visitFile(Path file,
                    java.nio.file.attribute.BasicFileAttributes attrs) throws IOException {
                Files.delete(file);
                return java.nio.file.FileVisitResult.CONTINUE;
            }
            @Override
            public java.nio.file.FileVisitResult postVisitDirectory(Path dir,
                    IOException exc) throws IOException {
                if (exc != null) throw exc;
                Files.delete(dir);
                return java.nio.file.FileVisitResult.CONTINUE;
            }
        };
        Files.walkFileTree(directory, visitor);
    }

    /**
     * Registers a JVM shutdown hook to ensure the Python subprocess is
     * terminated when QuPath exits (normally or via System.exit).
     * Does NOT protect against force-kill (Task Manager) -- the Python
     * side has its own parent-watcher for that case.
     */
    private void registerShutdownHook() {
        if (shutdownHook != null) return;
        shutdownHook = new Thread(() -> {
            logger.info("JVM shutdown hook: cleaning up Python subprocess");
            // Don't call shutdown() here (it tries to remove the hook)
            Service svc = pythonService;
            if (svc != null) {
                try {
                    svc.close();
                    // Brief wait, then force kill
                    if (svc.isAlive()) {
                        Thread.sleep(2000);
                    }
                    if (svc.isAlive()) {
                        svc.kill();
                    }
                } catch (Exception e) {
                    try { svc.kill(); } catch (Exception ignored) {}
                }
            }
        }, "DLClassifier-ShutdownHook");
        shutdownHook.setDaemon(false);
        Runtime.getRuntime().addShutdownHook(shutdownHook);
    }

    private void removeShutdownHook() {
        if (shutdownHook != null) {
            try {
                Runtime.getRuntime().removeShutdownHook(shutdownHook);
            } catch (IllegalStateException e) {
                // JVM is already shutting down -- expected if called from hook
            }
            shutdownHook = null;
        }
    }

    /**
     * Checks whether the Appose service is initialized and available.
     *
     * @return true if the service is ready for tasks
     */
    public boolean isAvailable() {
        return initialized && initError == null && pythonService != null;
    }

    /**
     * Gets the initialization error message, if any.
     *
     * @return error message, or null if no error
     */
    public String getInitError() {
        return initError;
    }

    /**
     * Checks whether CUDA (GPU) is available in the Python environment.
     * Only meaningful after successful initialization.
     *
     * @return true if CUDA GPU acceleration is available
     */
    public boolean isCudaAvailable() {
        return cudaAvailable;
    }

    // ==================== Classloader Workaround ====================

    /**
     * Executes a callable with the thread context classloader (TCCL) set to
     * the extension's classloader, then restores the original TCCL.
     * <p>
     * <b>Why this is needed:</b> Appose and its dependencies use
     * {@code ServiceLoader.load()} without specifying a classloader, so it
     * defaults to the TCCL. In plugin frameworks like QuPath, each extension
     * has its own classloader, and worker threads (e.g. QuPath's tile-rendering
     * pool) inherit the application classloader as their TCCL -- which cannot
     * see service registrations bundled in the extension's shadow JAR.
     * <p>
     * This affects multiple Appose operations:
     * <ul>
     *   <li><b>NDArray/SharedMemory</b>: {@code Plugins.create(ShmFactory.class)} on every allocation</li>
     *   <li><b>Task serialization</b>: Groovy's {@code FastStringService} for JSON encoding via {@code Messages.encode()}</li>
     *   <li><b>Environment build</b>: {@code Plugins.discover(Scheme.class)} and {@code Plugins.create(BuilderFactory.class)}</li>
     * </ul>
     * Without this workaround, operations fail with
     * {@code UnsupportedOperationException} or {@code Unable to load FastStringService}.
     *
     * @param callable the operation to run with the extension classloader
     * @param <T>      return type
     * @return the result of the callable
     * @throws Exception if the callable throws
     */
    public static <T> T withExtensionClassLoader(java.util.concurrent.Callable<T> callable) throws Exception {
        ClassLoader original = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader(ApposeService.class.getClassLoader());
        try {
            return callable.call();
        } finally {
            Thread.currentThread().setContextClassLoader(original);
        }
    }

    /**
     * Void variant of {@link #withExtensionClassLoader(java.util.concurrent.Callable)}
     * for operations that don't return a value.
     *
     * @param runnable the operation to run with the extension classloader
     * @throws Exception if the runnable throws
     */
    public static void runWithExtensionClassLoader(ThrowingRunnable runnable) throws Exception {
        ClassLoader original = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader(ApposeService.class.getClassLoader());
        try {
            runnable.run();
        } finally {
            Thread.currentThread().setContextClassLoader(original);
        }
    }

    /**
     * Functional interface for runnables that can throw checked exceptions.
     */
    @FunctionalInterface
    public interface ThrowingRunnable {
        void run() throws Exception;
    }

    // ==================== Internal Helpers ====================

    /**
     * Sends a status message to the callback, if present.
     */
    private static void report(Consumer<String> callback, String message) {
        if (callback != null) {
            callback.accept(message);
        }
    }

    /**
     * Strips ONNX-related lines from a pixi.toml string.
     * Removes lines containing 'onnx' or 'onnxruntime' dependency declarations.
     */
    private static String stripOnnxDependencies(String pixiToml) {
        StringBuilder sb = new StringBuilder();
        for (String line : pixiToml.split("\n")) {
            String trimmed = line.trim().toLowerCase();
            // Skip lines that are ONNX dependency declarations
            if (trimmed.startsWith("onnx ") || trimmed.startsWith("onnx=")
                    || trimmed.startsWith("onnxruntime ") || trimmed.startsWith("onnxruntime=")) {
                continue;
            }
            // Also skip comment lines immediately preceding ONNX deps
            if (trimmed.startsWith("# onnx")) {
                continue;
            }
            sb.append(line).append("\n");
        }
        return sb.toString();
    }

    /**
     * Ensures the pixi.toml on disk matches the bundled content.
     * If the content differs (e.g. after extension update), overwrites the
     * file and deletes pixi.lock to force pixi to re-resolve dependencies.
     * Also deletes .pixi/ so Appose doesn't skip the build.
     */
    private void syncPixiToml(String expectedContent) {
        try {
            Path envDir = getEnvironmentPath();
            Path pixiTomlFile = envDir.resolve("pixi.toml");
            if (!Files.exists(pixiTomlFile)) {
                return; // First-time install, Appose will create it
            }
            String existingContent = Files.readString(pixiTomlFile, StandardCharsets.UTF_8);
            // Normalize line endings for comparison
            String normalizedExisting = existingContent.replace("\r\n", "\n").strip();
            String normalizedExpected = expectedContent.replace("\r\n", "\n").strip();
            if (normalizedExisting.equals(normalizedExpected)) {
                return; // Content matches, no sync needed
            }
            logger.info("pixi.toml content changed - updating and forcing environment rebuild");
            Files.writeString(pixiTomlFile, expectedContent, StandardCharsets.UTF_8);
            // Delete lockfile so pixi re-resolves
            Files.deleteIfExists(envDir.resolve("pixi.lock"));
            // Delete .pixi/ so Appose doesn't skip the build
            Path pixiDir = envDir.resolve(".pixi");
            if (Files.isDirectory(pixiDir)) {
                deleteDirectoryRecursively(pixiDir);
            }
            logger.info("Environment sync complete - next build will re-resolve dependencies");
        } catch (IOException e) {
            logger.warn("Failed to sync pixi.toml (will attempt build anyway): {}", e.getMessage());
        }
    }

    // ==================== Resource Loading ====================

    private void ensureInitialized() throws IOException {
        if (!isAvailable()) {
            throw new IOException("Appose service is not available"
                    + (initError != null ? ": " + initError : ""));
        }
    }

    /**
     * Loads a Python script from JAR resources.
     *
     * @param scriptFileName script file name (e.g. "inference_pixel.py")
     * @return script content as string
     * @throws IOException if the script is not found
     */
    String loadScript(String scriptFileName) throws IOException {
        return loadResource(SCRIPTS_BASE + scriptFileName);
    }

    /**
     * Loads a text resource from the JAR.
     */
    private static String loadResource(String resourcePath) throws IOException {
        try (InputStream is = ApposeService.class.getClassLoader()
                .getResourceAsStream(resourcePath)) {
            if (is == null) {
                throw new IOException("Resource not found: " + resourcePath);
            }
            try (BufferedReader reader = new BufferedReader(
                    new InputStreamReader(is, StandardCharsets.UTF_8))) {
                return reader.lines().collect(Collectors.joining("\n"));
            }
        }
    }
}
